The double curly braces are Angular's interpolation binding syntax.
This interpolation binding presents the component's property value inside the HTML header tag.

You always import the Component symbol from the Angular core library
and annotate the component class with @Component.
@Component is a decorator function that specifies the Angular metadata for the component.

Pipes are a good way to format strings, currency amounts, dates, and other display data.
Angular ships with several built-in pipes, and you can create your own.

[(ngModel)] is Angular's two-way data binding syntax.
Although ngModel is a valid Angular directive, it isn't available by default.
It belongs to the optional FormsModule and you must opt in to using it.

Angular needs to know how the pieces of your application fit together and what other files
and libraries the application requires. This information is called metadata.

Some of the metadata is in the @Component decorators that you added to your component classes.
Other critical metadata is in @NgModule decorators.

The most important @NgModule decorator annotates the top-level AppModule class.

Add FormsModule to the imports array in @NgModule.
The imports array contains the list of external modules that the application needs.

Every component must be declared in exactly one NgModule.

(click) is Angular's event binding syntax.
The parentheses around click tell Angular to listen for the <button> element's click event.
When the user clicks in the <button>, Angular executes the onSelect(hero) expression.

The *ngIf directive tells Angular to render the section only when the condition is satisfied.

Angular's class binding can add and remove a CSS class conditionally.
Add [class.some-css-class]="some-condition" to the element you want to style.

Components shouldn't fetch or save data directly, and they certainly shouldn't knowingly 
present fake data. They should focus on presenting data and delegate data access to a service.

If the Angular "Injectable" symbol annotates a class with the @Injectable() decorator,
then this marks the class as one that participates in the dependency injection system.
The class is going to provide an injectable service, and it can also have its own injected dependencies.

The @Injectable() decorator accepts a metadata object for the service, the same way 
the @Component() decorator did for your component classes.

Provider scope for now is in "root". For futher reading :
https://angular.io/tutorial/tour-of-heroes/toh-pt4#provide-the-heroservice
https://angular.io/guide/dependency-injection
https://angular.io/guide/providers

Reserve the constructor for minimal initialization such as wiring constructor parameters
to properties. The constructor shouldn't do anything. 
It certainly shouldn't call a function that makes HTTP requests 
to a remote server as a real data service would.

When you want to use services in a template, you should set it to public in constructor.
Angular only binds to public component properties.

The <router-outlet> tells the router where to display routed views.
The RouterOutlet is one of the router directives that became available to the AppComponent
because AppModule imports AppRoutingModule which exported RouterModule. 
The ng generate command you ran at the start of this tutorial added this import because of
the --module=app flag. 

If you didn't use the ng generate command to create app-routing.module.ts,
import AppRoutingModule into app.module.ts and add it to the imports array of the NgModule.

A routerLink attribute is set to "/heroes", the string that the router matches to the route
to HeroesComponent. The routerLink is the selector for the RouterLink directive that turns
user clicks into router navigations. It's another of the public directives in the RouterModule.

// this.route.snapshot.paramMap.get('id')
The route.snapshot is a static image of the route information shortly after the component was created.
The paramMap is a dictionary of route parameter values extracted from the URL. 
The "id" key returns the id of the hero to fetch.